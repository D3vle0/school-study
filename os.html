<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>운영체제 정리</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#운영체제의-자원관리">운영체제의 자원관리</a>
<ul>
<li><a href="#운영-체제">운영 체제</a></li>
<li><a href="#명령-처리-방식에-따른-분류">명령 처리 방식에 따른 분류</a></li>
<li><a href="#운영-시스템에-따른-분류">운영 시스템에 따른 분류</a></li>
<li><a href="#프로세스-제어-블럭-pcb">프로세스 제어 블럭 (PCB)</a></li>
<li><a href="#프로세스의-상태">프로세스의 상태</a></li>
<li><a href="#프로세스-스케줄링">프로세스 스케줄링</a></li>
<li><a href="#주기억장치-관리">주기억장치 관리</a></li>
<li><a href="#보조-기억-장치-관리">보조 기억 장치 관리</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="운영체제의-자원관리">운영체제의 자원관리</h1>
<h2 id="운영-체제">운영 체제</h2>
<ol>
<li>사용자가 컴퓨터 시스템의 프로그램을 쉽고 효율적으로 실행하는 환경 제공</li>
<li>사용자 프로그램의 오류, 잘못된 자원 사용 등 감시, 입출력 장치 등의 자원에 대한 운영과 제어</li>
</ol>
<h3 id="운영-체제의-구성">운영 체제의 구성</h3>
<ul>
<li>커널: 사용자와 하드웨어 사이에서 중재 역할</li>
<li>프로세스 관리, 동기화 및 통신, 메모리 관리, 입출력 관리 등의 핵심기능 수행</li>
<li>펌웨어와 장치 드라이버의 도움을 받아 모든 컴퓨터 하드웨어 장치에 대한 가장 기초 수준의 제어권을 얻음</li>
<li>유저 인터페이스: 사용자가 컴퓨터 시스템을 운용할 수 있게 해주는 쉘</li>
<li>사용자가 컴퓨터 시스템에 요청하는 동작들을 수행</li>
<li>필수 유틸리티</li>
<li>서비스, 언어 번역, 문제 처리 프로그램 등 기본 제공 프로그램</li>
</ul>
<h2 id="명령-처리-방식에-따른-분류">명령 처리 방식에 따른 분류</h2>
<ol>
<li>일괄 처리 방식 (Batch Processing)
<ul>
<li>처리할 데이터를 일정량 모아서 한번에 처리</li>
<li>장점: 컴퓨터 시스템을 효율적으로 이용</li>
<li>단점: 결과를 얻기까기 대기 시간이 길다</li>
</ul>
</li>
<li>실시간 처리 방식 (Real Time Processing) : 실시간 운영체제
<ul>
<li>데이터가 발생한 시점에서 즉시 처리하는 방식</li>
<li>장점: 처리 결과를 빨리 얻을 수 있다</li>
<li>단점: 고성능의 시스템 요구</li>
</ul>
</li>
<li>다중 프로그래밍 방식 (Multi-programming)
<ul>
<li>여러 개의 프로그램을 동시에 주기억 장치에 적재한 후 CPU를 번갈아 할당</li>
<li>CPU 작업 효율을 높임</li>
</ul>
</li>
<li>다중 처리 방식 (multi-processing)
<ul>
<li>2개 이상의 프로세서를 사용하여 프로그램을 동시에 처리</li>
<li>병렬로 처리하므로 속도 빠름</li>
</ul>
</li>
<li>시분할 처리 방식 (Time Sharing System)
<ul>
<li>대부분의 중대형 컴퓨터에서 사용하는 방식으로, CPU 사용시간을 분할함</li>
<li>하나의 시스템에 여러 사용자가 동시에 접속하여 작업을 수행할 때 효과적</li>
<li>CPU 스케줄링을 통해 각각의 사용자는 자신 혼자만 사용하는 것 처럼 느낌</li>
</ul>
</li>
<li>분산 처리 시스템 (Distributed Processing System) : 분산 운영체제
<ul>
<li>지리적으로 떨어져있는 여러 대의 시스템에 데이터를 지리적, 기능적으로 분산 후 처리</li>
<li>장점: 다수 사용자의 데이터 공유 가능, 확장 용이</li>
<li>단점: 비용, 설계 복잡</li>
</ul>
</li>
</ol>
<h2 id="운영-시스템에-따른-분류">운영 시스템에 따른 분류</h2>
<ul>
<li>개인용 컴퓨터 운영체제</li>
<li>일반적으로 단일 사용자 운영체제 사용</li>
<li>현재에는 대부분 그래픽 사용자 인터페이스 사용<br>
EX) Windows, Linux, Mac os</li>
<li>메인프레임 운영체제</li>
<li>일반적으로 다중 사용자 운영체제 사용</li>
<li>최근에는 그래픽 사용자 인터페이스 사용<br>
EX) Unix, Solaris</li>
<li>임베디드 운영체제</li>
<li>임베디드 컴퓨터 시스템에서 사용할 수 있게 설계되어 있음</li>
<li>크기가 매우 작고 극히 효율적으로 설계되어 있음<br>
EX) Embeded Linux, Windows CE</li>
</ul>
<h2 id="프로세스-제어-블럭-pcb">프로세스 제어 블럭 (PCB)</h2>
<ol>
<li>프로세스의 상태: 실행 상태인지, 준비 상태인지 정보</li>
<li>프로그램 카운터값: CPU 프로그램 카운터 레지스터에 저장된 값, 다음에 실행될 명령어의 주기억 장치 주소를 의미</li>
<li>스케줄링 정보: 다음에 실행될 프로세스를 결정하는데 필요한 정보, 프로세스 스케줄링 정책, 우선순위 등을 의미</li>
<li>주기억 장치 정보: 해당 프로세스가 주기억 장치의 어느 영역에 있는지에 대한 정보</li>
</ol>
<h2 id="프로세스의-상태">프로세스의 상태</h2>
<ol>
<li>준비큐에서 이전 프로세스의 실행이 종료된 경우 :
<ul>
<li>스케줄링 정책에 따라 가장 먼저 실행될 프로세스가 실행 상태(running)가 됨</li>
</ul>
</li>
<li>이전 프로세스가 CPU를 오래 차지 :
<ul>
<li>프로세스를 준비 상태(ready)가 되게 하고 - &gt; Time out(Interrupt)</li>
<li>가장 먼저 실행될 프로세스가 실행 상태(running)가 됨 - &gt; dispatch</li>
<li>CPU 일부 레지스터에 저장된 이전 프로세스 정보와 새 프로세스 정보를 레지스터에 저장하는 것을 문맥 전환(Context switch)이라 함</li>
</ul>
</li>
<li>실행 프로세스가 디스크 입출력을 실행할 경우 :
<ul>
<li>해당 프로세스를 대기 큐(waiting)로 보냄 - &gt; I/O Event</li>
<li>가장 먼저 실행될 프로세스가 실행 상태(running)가 됨 - &gt; dispatch</li>
<li>대기 상태에서도 문맥 전환이 일어남</li>
</ul>
</li>
</ol>
<p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/d2d91f7b-3c17-4ed6-937a-8a1799b42408/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210112%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20210112T080410Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=638177e1971867e4a19a9a6aec87b8313ff444392dc322adb7e19768f5007e15&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt=""></p>
<h2 id="프로세스-스케줄링">프로세스 스케줄링</h2>
<ol>
<li>FCFS (선입선출, 비선점형)</li>
<li>RR (라운드 로빈, 일정 시간동안 돌아가면서 처리, 선점형)</li>
<li>SJF (실행시간 짧은 작업을 먼저 처리, 비선점형)</li>
<li>우선순위 스케줄링 (PCB에 저장된 우선순위에 따라 처리)</li>
<li>HRN <code>(대기시간 + 실행시간) / 실행시간</code> 이 높은 순으로 처리, 비선점형)</li>
</ol>
<p>선점형: 하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할 수 있음<br>
비선점형: 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음</p>
<p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/010e2a73-3de9-40c4-851a-de223ee42440/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210112%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20210112T080429Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=d688b10c26a455164071029f5f48fff87a211a11bc6ff00e1463d5ed7460e04c&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt=""></p>
<p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/0fdb4323-0f71-4d0c-b174-067aebe72a53/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210112%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20210112T080449Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=f0f434291a045ba76097ff0832fc975e47c247b79b0047a545a2cd0d5d2c2914&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt=""></p>
<p>평균 대기시간 : 각 프로세스들의 대기시간 <code>(수행이 시작한 시간 - 도착한 시간)</code> 의 합의 평균</p>
<p>평균 반환시간 : 각 프로세스들이 완료된 시간 <code>(수행이 시작한 시간 + 실행된 시간 - 도착한 시간)</code> 의 합의 평균</p>
<p>반환 시간 = <code>(대기 시간의 합 + 실행 시간의 합)/N</code>이므로, 평균 반환시간은 평균 대기시간과 평균 실행 시간의 합과 같다.</p>
<h2 id="주기억장치-관리">주기억장치 관리</h2>
<h3 id="반입-기법">반입 기법</h3>
<p>보조 기억장치에 저장된 프로그램이나 데이터를 언제 주기억장치로 가져올 것인지 결정</p>
<ol>
<li>요구 반입
<ul>
<li>실행중인 프로그램이 참조를 요구할때 가져오는 방법</li>
</ul>
</li>
<li>예상 반입
<ul>
<li>실행중인 프로그램에 의해 참조될 것을 예상하여 미리 가져오는 방법</li>
</ul>
</li>
</ol>
<h3 id="배치-기법">배치 기법</h3>
<p>보조 기억장치로부터 가져온 프로그램이나 데이터를 주기억 장치의 어느 위치에 저장할 것인가를 결정</p>
<ol>
<li>최초 적합
<ul>
<li>프로그램의 크기보다 큰 최초의 영역에 배치</li>
</ul>
</li>
<li>최적 적합
<ul>
<li>프로그램의 크기와 가장 유사한 영역에 배치</li>
</ul>
</li>
<li>최악 적합
<ul>
<li>프로그램이 들어갈 수 있는 영역 중 가장 큰 영역에 배치</li>
</ul>
</li>
</ol>
<h3 id="교체-기법">교체 기법</h3>
<p>배치 되어야 하는데 배치할 공간이 없어서 어느 영역을 교체하여 사용할 것인지 결정</p>
<ol>
<li>FIFO
<ul>
<li>주기억 장치에 배치된 시간이 가장 오래된 영역을 교체</li>
<li>각 페이지가 적재될때마다 시간 또는 순서를 큐에 기억함</li>
<li>알고리즘이 간단</li>
<li>페이지 부재가 가장 많이 발생</li>
</ul>
</li>
<li>LRU
<ul>
<li>가장 오랫동안 사용되지 않은 영역을 교체</li>
<li>FIFO 보다 효율적</li>
</ul>
</li>
<li>LFU
<ul>
<li>가장 사용된 횟수가 적은 영역을 교체</li>
<li>초기에 한 페이지를 집중적으로 참조하다가 이후 참조하지 않는 경우, 메모리에 남아있어 문제가 될 수 있음</li>
<li>구현이 어렵다</li>
</ul>
</li>
</ol>
<h3 id="단편화">단편화</h3>
<p>기억장치의 저장공간이 프로그램과 데이터를 배치하고 교체하는 과정에서 남게 되는 작은 조각 공간</p>
<ol>
<li>내부 단편화
<ul>
<li>필요한 크기에 비해서 실제 배정된 공간의 크기가 커서 사용하지 않는 부분이 있을 때</li>
</ul>
</li>
<li>외부 단편화
<ul>
<li>필요한 크기에 비해서 실제 배정된 공간의 크기가 작아서 사용하지 않는 부분이 있을 때</li>
</ul>
</li>
</ol>
<h3 id="단편화-해결-방법">단편화 해결 방법</h3>
<ol>
<li>통합 기법
<ul>
<li>인접해 있는 공간을 하나의 공간으로 만드는 것</li>
</ul>
</li>
<li>압축 기법
<ul>
<li>빈 공간을 재배치하여 비연속적으로 흩어져있는 공간을 모아 합치는 것</li>
</ul>
</li>
</ol>
<h2 id="보조-기억-장치-관리">보조 기억 장치 관리</h2>
<h3 id="자료-접근-방법">자료 접근 방법</h3>
<ol>
<li>순차 접근 방식
<ul>
<li>순서대로 진행하며 접근하는 방식</li>
<li>ex) 테이프</li>
</ul>
</li>
<li>직접 접근 방식
<ul>
<li>저장 위치에 관계없이 직접 접근이 가능한 방식</li>
<li>ex) 디스크 장치</li>
</ul>
</li>
</ol>
<h3 id="디스크-스케줄링">디스크 스케줄링</h3>
<ol>
<li>FCFS
<ul>
<li>대기 큐에 들어온 순서대로 탐색</li>
<li>탐색 거리를 최소화 하지 못하는 단점</li>
</ul>
</li>
<li>SSTF
<ul>
<li>탐색거리가 짧은 순으로 탐색</li>
<li>응답 시간의 편차가 커서 요청에 대한 서비스를 계속 기다리는 기아 상태 발생</li>
</ul>
</li>
<li>SCAN
<ul>
<li>이전 위치에서 현재 위치 방향으로 트랙 끝까지 탐색 후 반대방향으로 탐색</li>
<li>진행 방향으로 요청이 오면 바로 서비스 받을 수 있지만 진행 반대 방향이라면 기다려야 함</li>
</ul>
</li>
<li>C-SCAN
<ul>
<li>항상 바깥쪽에서 안쪽으로 탐색(바깥쪽이 0, 안쪽이 199 순)</li>
</ul>
</li>
</ol>
<p>디스크 스케줄링을 쉽게 공부하고 싶다면 <a href="https://github.com/d3vle0/disk-scheduling">https://github.com/d3vle0/disk-scheduling</a></p>

    </div>
  </div>
</body>

</html>
